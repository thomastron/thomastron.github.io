<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic City Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: white;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            width: 300px;
            z-index: 100;
        }
        .slider-container {
            margin-bottom: 10px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #444;
            outline: none;
            border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #00c6ff;
            border-radius: 50%;
            cursor: pointer;
        }
        h1 {
            position: absolute;
            top: 20px;
            left: 20px;
            margin: 0;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 198, 255, 0.8);
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #loading h2 {
            color: #00c6ff;
            margin-bottom: 20px;
        }
        #progressBar {
            width: 300px;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
        }
        #progressFill {
            height: 100%;
            width: 0%;
            background-color: #00c6ff;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h2>Building your futuristic city...</h2>
        <div id="progressBar">
            <div id="progressFill"></div>
        </div>
    </div>
    
    <h1>NEON HORIZON 2150</h1>
    
    <div id="controls">
        <div class="slider-container">
            <label for="timeSlider">Time of Day</label>
            <input type="range" id="timeSlider" min="0" max="24" step="0.1" value="12">
        </div>
        <div class="slider-container">
            <label for="trafficSlider">Traffic Density</label>
            <input type="range" id="trafficSlider" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="slider-container">
            <label for="fogSlider">Fog Intensity</label>
            <input type="range" id="fogSlider" min="0" max="0.01" step="0.0001" value="0.001">
        </div>
        <div class="slider-container">
            <label for="neonSlider">Neon Intensity</label>
            <input type="range" id="neonSlider" min="0" max="1" step="0.01" value="0.7">
        </div>
        <div class="slider-container">
            <label for="cameraHeightSlider">Camera Height</label>
            <input type="range" id="cameraHeightSlider" min="5" max="500" step="1" value="100">
        </div>
    </div>

    <script>
        // Loading screen
        const progressFill = document.getElementById('progressFill');
        const loadingScreen = document.getElementById('loading');
        let loadingProgress = 0;
        
        function updateProgress(value) {
            loadingProgress = Math.min(value, 100);
            progressFill.style.width = loadingProgress + '%';
            if (loadingProgress >= 100) {
                setTimeout(() => {
                    loadingScreen.style.opacity = 0;
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }, 500);
            }
        }

        // Initialize scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // Add fog
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        // Textures
        const textureLoader = new THREE.TextureLoader();
        
        // Create sky
        const skyGeometry = new THREE.SphereGeometry(5000, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Create stars
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 1,
            transparent: true,
            opacity: 0,
            sizeAttenuation: true
        });

        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 10000;
            const y = (Math.random() - 0.5) * 10000;
            const z = (Math.random() - 0.5) * 10000;
            // Make sure stars are outside the city
            if (Math.abs(x) < 1000 && Math.abs(z) < 1000) continue;
            starVertices.push(x, y, z);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(2000, 2000, 20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.8,
            metalness: 0.3
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Create grid lines
        const gridHelper = new THREE.GridHelper(2000, 100, 0x00ffff, 0x004444);
        gridHelper.position.y = 0.1;
        scene.add(gridHelper);
        
        // City parameters
        const citySize = 1000;
        const districtSize = 200;
        const blockSize = 20;
        const streetWidth = 10;
        const buildingGap = 2;
        
        // Materials for buildings
        const buildingMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.2 }),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.1 }),
            new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6, metalness: 0.3 }),
            new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5, metalness: 0.4 })
        ];
        
        // Materials for neon
        const neonMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1 }),
            new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 1 }),
            new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 }),
            new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1 }),
            new THREE.MeshStandardMaterial({ color: 0xff0066, emissive: 0xff0066, emissiveIntensity: 1 })
        ];
        
        // Group to hold all buildings
        const buildings = new THREE.Group();
        scene.add(buildings);
        
        // Group to hold all neon elements
        const neonElements = new THREE.Group();
        scene.add(neonElements);
        
        // Group to hold all vehicles
        const vehicles = new THREE.Group();
        scene.add(vehicles);
        
        // Create city layout
        function createCity() {
            const totalBuildings = 1000;
            let buildingsCreated = 0;
            
            // Create city in multiple batches to avoid blocking the main thread
            const createBatch = () => {
                const batchSize = 50;
                
                for (let i = 0; i < batchSize && buildingsCreated < totalBuildings; i++) {
                    // Random position for the building inside the city bounds
                    const x = (Math.random() - 0.5) * citySize;
                    const z = (Math.random() - 0.5) * citySize;
                    
                    // Skip if position is on a main street
                    if (isOnMainStreet(x, z)) continue;
                    
                    // Calculate building dimensions
                    const buildingHeight = Math.random() * 80 + 20; // 20 to 100 units
                    const importance = Math.random(); // Building importance factor
                    
                    if (importance > 0.95) {
                        // Skyscraper
                        createSkyscraper(x, z, buildingHeight * 5);
                    } else if (importance > 0.8) {
                        // Large building
                        createModernBuilding(x, z, buildingHeight * 2);
                    } else {
                        // Regular building
                        createSimpleBuilding(x, z, buildingHeight);
                    }
                    
                    buildingsCreated++;
                }
                
                // Update progress
                updateProgress((buildingsCreated / totalBuildings) * 100);
                
                // Continue with next batch or finish
                if (buildingsCreated < totalBuildings) {
                    setTimeout(createBatch, 0);
                } else {
                    createHighways();
                    createVehicles();
                    updateProgress(100);
                }
            };
            
            createBatch();
        }
        
        // Check if a position is on a main street
        function isOnMainStreet(x, z) {
            // Main streets are at every 100 units with width of 15 units
            const streetWidth = 15;
            const streetInterval = 100;
            
            // Check if position is on an X or Z aligned street
            for (let i = -citySize/2; i <= citySize/2; i += streetInterval) {
                if (Math.abs(x - i) < streetWidth/2 || Math.abs(z - i) < streetWidth/2) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Create a simple box building
        function createSimpleBuilding(x, z, height) {
            const width = Math.random() * 10 + 5;
            const depth = Math.random() * 10 + 5;
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];
            
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            
            buildings.add(building);
            
            // Add neon strips with probability
            if (Math.random() > 0.7) {
                addNeonToBuilding(building, width, height, depth);
            }
        }
        
        // Create a modern building with setbacks
        function createModernBuilding(x, z, height) {
            const baseWidth = Math.random() * 15 + 10;
            const baseDepth = Math.random() * 15 + 10;
            
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            
            // Multiple sections with decreasing size
            const numSections = Math.floor(Math.random() * 3) + 2;
            let currentHeight = 0;
            
            for (let i = 0; i < numSections; i++) {
                const sectionHeight = height * (1 - i/numSections) / numSections;
                const sectionWidth = baseWidth * (1 - i * 0.2);
                const sectionDepth = baseDepth * (1 - i * 0.2);
                
                const geometry = new THREE.BoxGeometry(sectionWidth, sectionHeight, sectionDepth);
                const material = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];
                
                const section = new THREE.Mesh(geometry, material);
                section.position.y = currentHeight + sectionHeight/2;
                section.castShadow = true;
                section.receiveShadow = true;
                
                group.add(section);
                
                // Add neon to this section
                if (Math.random() > 0.5) {
                    const neonGeo = new THREE.BoxGeometry(sectionWidth + 0.1, 0.2, sectionDepth + 0.1);
                    const neonMat = neonMaterials[Math.floor(Math.random() * neonMaterials.length)];
                    const neon = new THREE.Mesh(neonGeo, neonMat);
                    neon.position.y = currentHeight + sectionHeight;
                    neonElements.add(neon);
                    group.add(neon);
                }
                
                currentHeight += sectionHeight;
            }
            
            buildings.add(group);
        }
        
        // Create a skyscraper
        function createSkyscraper(x, z, height) {
            const width = Math.random() * 20 + 15;
            const depth = Math.random() * 20 + 15;
            
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            
            // Create main structure
            const mainGeometry = new THREE.BoxGeometry(width, height * 0.9, depth);
            const mainMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.2,
                metalness: 0.8
            });
            
            const mainStructure = new THREE.Mesh(mainGeometry, mainMaterial);
            mainStructure.position.y = height * 0.9 / 2;
            mainStructure.castShadow = true;
            mainStructure.receiveShadow = true;
            group.add(mainStructure);
            
            // Create top spire
            const spireGeometry = new THREE.ConeGeometry(width * 0.2, height * 0.3, 4);
            const spireMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.1,
                metalness: 0.9
            });
            
            const spire = new THREE.Mesh(spireGeometry, spireMaterial);
            spire.position.y = height * 0.9 + height * 0.3 / 2;
            spire.castShadow = true;
            spire.receiveShadow = true;
            group.add(spire);
            
            // Add vertical neon strips
            for (let i = 0; i < 4; i++) {
                const neonMat = neonMaterials[Math.floor(Math.random() * neonMaterials.length)];
                const neonGeo = new THREE.BoxGeometry(0.5, height * 0.8, 0.5);
                const neon = new THREE.Mesh(neonGeo, neonMat);
                
                const angle = (i / 4) * Math.PI * 2;
                neon.position.x = (width/2 - 0.5) * Math.cos(angle);
                neon.position.z = (depth/2 - 0.5) * Math.sin(angle);
                neon.position.y = height * 0.8 / 2;
                
                neonElements.add(neon);
                group.add(neon);
            }
            
            buildings.add(group);
        }
        
        // Add neon details to a building
        function addNeonToBuilding(building, width, height, depth) {
            const neonType = Math.floor(Math.random() * 3);
            const neonMat = neonMaterials[Math.floor(Math.random() * neonMaterials.length)];
            
            if (neonType === 0) {
                // Horizontal strip at top
                const neonGeo = new THREE.BoxGeometry(width + 0.2, 0.3, depth + 0.2);
                const neon = new THREE.Mesh(neonGeo, neonMat);
                neon.position.copy(building.position);
                neon.position.y = building.position.y + height/2;
                neonElements.add(neon);
            } else if (neonType === 1) {
                // Vertical strip on side
                const neonGeo = new THREE.BoxGeometry(0.3, height, 0.3);
                const neon = new THREE.Mesh(neonGeo, neonMat);
                neon.position.copy(building.position);
                neon.position.x += width/2;
                neon.position.z += depth/2;
                neonElements.add(neon);
            } else {
                // Window grid
                const rows = Math.floor(height / 5);
                const cols = Math.floor(width / 3);
                
                if (rows > 0 && cols > 0) {
                    const neonGeo = new THREE.BoxGeometry(width * 0.8, height * 0.8, 0.1);
                    const neon = new THREE.Mesh(neonGeo, neonMat);
                    neon.position.copy(building.position);
                    neon.position.z += depth/2 + 0.1;
                    neon.material.opacity = 0.3;
                    neon.material.transparent = true;
                    neonElements.add(neon);
                }
            }
        }
        
        // Create highways
        function createHighways() {
            // Main highway in X direction
            createHighway(-citySize/2, 5, 0, citySize, 30, 0);
            
            // Main highway in Z direction
            createHighway(0, 5, -citySize/2, 30, citySize, Math.PI/2);
            
            // Secondary highways
            createHighway(-citySize/2, 5, citySize/4, citySize, 20, 0);
            createHighway(-citySize/4, 5, -citySize/2, 20, citySize, Math.PI/2);
            
            // Add elevated sections
            for (let i = 0; i < 5; i++) {
                const x = (Math.random() - 0.5) * citySize * 0.8;
                const z = (Math.random() - 0.5) * citySize * 0.8;
                const length = Math.random() * 200 + 100;
                const height = Math.random() * 20 + 15;
                const rotation = Math.random() * Math.PI;
                
                createElevatedHighway(x, height, z, length, 15, rotation);
            }
        }
        
        // Create a highway segment
        function createHighway(x, y, z, width, length, rotation) {
            const geometry = new THREE.BoxGeometry(width, 1, length);
            const material = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const highway = new THREE.Mesh(geometry, material);
            highway.position.set(x + width/2, y, z + length/2);
            highway.rotation.y = rotation;
            highway.receiveShadow = true;
            scene.add(highway);
            
            // Add lane markings
            const lanes = Math.floor(width / 5);
            if (lanes > 1) {
                for (let i = 1; i < lanes; i++) {
                    const markingGeo = new THREE.BoxGeometry(0.5, 1.1, length);
                    const markingMat = new THREE.MeshStandardMaterial({
                        color: 0xFFFFFF,
                        emissive: 0xFFFFFF,
                        emissiveIntensity: 0.2
                    });
                    
                    const marking = new THREE.Mesh(markingGeo, markingMat);
                    marking.position.copy(highway.position);
                    marking.position.x = highway.position.x - width/2 + i * (width/lanes);
                    marking.rotation.y = rotation;
                    scene.add(marking);
                }
            }
            
            // Add guardrails
            const railGeo = new THREE.BoxGeometry(width, 1.5, 1);
            const railMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.6,
                metalness: 0.4
            });
            
            for (let side = -1; side <= 1; side += 2) {
                const rail = new THREE.Mesh(railGeo, railMat);
                rail.position.copy(highway.position);
                
                if (rotation === 0) {
                    rail.position.z += side * length/2;
                } else {
                    rail.position.x += side * length/2;
                }
                
                rail.rotation.y = rotation;
                scene.add(rail);
            }
            
            return highway;
        }
        
        // Create an elevated highway section
        function createElevatedHighway(x, y, z, width, length, rotation) {
            // Create the elevated highway
            const highway = createHighway(x, y, z, width, length, rotation);
            
            // Add supports
            const numSupports = Math.ceil(length / 30);
            const supportGeo = new THREE.CylinderGeometry(2, 2, y, 8);
            const supportMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.3
            });
            
            for (let i = 0; i < numSupports; i++) {
                const support = new THREE.Mesh(supportGeo, supportMat);
                const offsetX = (i - (numSupports-1)/2) * (length / (numSupports-1));
                
                support.position.copy(highway.position);
                support.position.y = y/2;
                
                if (rotation === 0) {
                    support.position.z += offsetX;
                } else {
                    support.position.x += Math.cos(rotation) * offsetX;
                    support.position.z += Math.sin(rotation) * offsetX;
                }
                
                scene.add(support);
            }
            
            return highway;
        }
        
        // Create vehicles
        function createVehicles() {
            // Create different vehicle types
            for (let i = 0; i < 100; i++) {
                const type = Math.floor(Math.random() * 3);
                let vehicle;
                
                switch (type) {
                    case 0: // Car
                        vehicle = createCar();
                        break;
                    case 1: // Truck
                        vehicle = createTruck();
                        break;
                    case 2: // Flying vehicle
                        vehicle = createFlyingVehicle();
                        break;
                }
                
                // Add to group
                vehicles.add(vehicle);
            }
        }
        
        // Create a car
        function createCar() {
            const group = new THREE.Group();
            
            // Car body
            const bodyGeo = new THREE.BoxGeometry(4, 1, 2);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xFFFFFF,
                roughness: 0.2,
                metalness: 0.8
            });
            
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            group.add(body);
            
            // Car top
            const topGeo = new THREE.BoxGeometry(2, 1, 2);
            const top = new THREE.Mesh(topGeo, bodyMat);
            top.position.y = 1;
            top.position.x = -0.5;
            group.add(top);
            
            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            const wheelMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.9,
                metalness: 0.1
            });
            
            for (let x = -1; x <= 1; x += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.position.set(x, -0.5, z);
                    wheel.rotation.z = Math.PI/2;
                    group.add(wheel);
                }
            }
            
            // Lights
            const headlightGeo = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const headlightMat = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 1
            });
            
            for (let z = -0.5; z <= 0.5; z += 1) {
                const headlight = new THREE.Mesh(headlightGeo, headlightMat);
                headlight.position.set(2, 0, z);
                group.add(headlight);
            }
            
            const taillightGeo = new THREE.BoxGeometry(0.1, 0.3, 0.3);
            const taillightMat = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 1
            });
            
            for (let z = -0.5; z <= 0.5; z += 1) {
                const taillight = new THREE.Mesh(taillightGeo, taillightMat);
                taillight.position.set(-2, 0, z);
                group.add(taillight);
            }
            
            // Position on a road
            positionVehicleOnRoad(group);
            
            return group;
        }
        
        // Create a truck
        function createTruck() {
            const group = new THREE.Group();
            
            // Truck cab
            const cabGeo = new THREE.BoxGeometry(3, 2.5, 2.5);
            const cabMat = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xFFFFFF,
                roughness: 0.3,
                metalness: 0.7
            });
            
            const cab = new THREE.Mesh(cabGeo, cabMat);
            cab.position.x = 2.5;
            group.add(cab);
            
            // Truck trailer
            const trailerGeo = new THREE.BoxGeometry(8, 3, 2.8);
            const trailerMat = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xFFFFFF,
                roughness: 0.5,
                metalness: 0.5
            });
            
            const trailer = new THREE.Mesh(trailerGeo, trailerMat);
            trailer.position.x = -3;
            group.add(trailer);
            
            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16);
            const wheelMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.9,
                metalness: 0.1
            });
            
            // Cab wheels
            for (let z = -1; z <= 1; z += 2) {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.position.set(2, -1.3, z * 1.5);
                wheel.rotation.z = Math.PI/2;
                group.add(wheel);
            }
            
            // Trailer wheels
            for (let x = -6; x <= -1; x += 2.5) {
                for (let z = -1; z <= 1; z += 2) {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.position.set(x, -1.5, z * 1.5);
                    wheel.rotation.z = Math.PI/2;
                    group.add(wheel);
                }
            }
            
            // Lights
            const headlightGeo = new THREE.BoxGeometry(0.1, 0.4, 0.4);
            const headlightMat = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 1
            });
            
            for (let z = -0.8; z <= 0.8; z += 1.6) {
                const headlight = new THREE.Mesh(headlightGeo, headlightMat);
                headlight.position.set(4, 0, z);
                group.add(headlight);
            }
            
            // Position on a road
            positionVehicleOnRoad(group);
            
            return group;
        }
        
        // Create a flying vehicle
        function createFlyingVehicle() {
            const group = new THREE.Group();
            
            // Main body
            const bodyGeo = new THREE.ConeGeometry(1.5, 5, 4);
            bodyGeo.rotateX(Math.PI/2);
            
            const bodyMat = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xFFFFFF,
                roughness: 0.2,
                metalness: 0.9
            });
            
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            group.add(body);
            
            // Wings
            const wingGeo = new THREE.BoxGeometry(1, 0.2, 4);
            const wing = new THREE.Mesh(wingGeo, bodyMat);
            wing.position.y = 0.5;
            group.add(wing);
            
            // Thrusters
            const thrusterGeo = new THREE.CylinderGeometry(0.5, 0.8, 1, 16);
            const thrusterMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.2,
                metalness: 0.8
            });
            
            for (let z = -1; z <= 1; z += 2) {
                const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);
                thruster.position.set(-2.5, 0, z);
                thruster.rotation.z = Math.PI/2;
                group.add(thruster);
                
                // Thruster glow
                const glowGeo = new THREE.CylinderGeometry(0.3, 0.6, 0.1, 16);
                const glowMat = new THREE.MeshStandardMaterial({
                    color: 0x00FFFF,
                    emissive: 0x00FFFF,
                    emissiveIntensity: 1
                });
                
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.set(-3, 0, z);
                glow.rotation.z = Math.PI/2;
                group.add(glow);
            }
            
            // Lights
            const lightGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const lightMat = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 1
            });
            
            const light = new THREE.Mesh(lightGeo, lightMat);
            light.position.y = 1;
            group.add(light);
            
            // Position randomly in air
            const x = (Math.random() - 0.5) * citySize;
            const y = Math.random() * 200 + 50;
            const z = (Math.random() - 0.5) * citySize;
            
            group.position.set(x, y, z);
            group.rotation.y = Math.random() * Math.PI * 2;
            
            // Add data for animation
            group.userData = {
                speed: Math.random() * 0.5 + 0.2,
                wobble: Math.random() * 0.05,
                wobbleSpeed: Math.random() * 0.05 + 0.01
            };
            
            return group;
        }
        
        // Position a vehicle on a road
        function positionVehicleOnRoad(vehicle) {
            // Get a random main street
            const streetWidth = 15;
            const streetInterval = 100;
            
            const onXAxis = Math.random() > 0.5;
            const streetIndex = Math.floor(Math.random() * (citySize / streetInterval)) - Math.floor(citySize / streetInterval / 2);
            const streetPos = streetIndex * streetInterval;
            
            // Position on street
            if (onXAxis) {
                const x = (Math.random() - 0.5) * citySize;
                const y = 1;
                const z = streetPos + (Math.random() - 0.5) * (streetWidth - 4);
                
                vehicle.position.set(x, y, z);
                vehicle.rotation.y = Math.PI / 2;
            } else {
                const x = streetPos + (Math.random() - 0.5) * (streetWidth - 4);
                const y = 1;
                const z = (Math.random() - 0.5) * citySize;
                
                vehicle.position.set(x, y, z);
            }
            
            // Store direction and speed
            vehicle.userData = {
                speed: Math.random() * 0.5 + 0.2,
                direction: Math.sign(Math.random() - 0.5)
            };
        }
        
        // Lights setup
        function setupLights() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.2);
            scene.add(ambientLight);
            
            // Sun directional light
            const sunLight = new THREE.DirectionalLight(0xFFFFFF, 1);
            sunLight.position.set(500, 1000, 200);
            sunLight.castShadow = true;
            
            // Configure shadow properties
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1500;
            sunLight.shadow.camera.left = -citySize;
            sunLight.shadow.camera.right = citySize;
            sunLight.shadow.camera.top = citySize;
            sunLight.shadow.camera.bottom = -citySize;
            
            scene.add(sunLight);
            
            // Additional point lights around the city
            const colors = [0x00ffff, 0xff00ff, 0xffff00, 0xff0000, 0x0000ff];
            
            for (let i = 0; i < 10; i++) {
                const x = (Math.random() - 0.5) * citySize;
                const y = Math.random() * 100 + 20;
                const z = (Math.random() - 0.5) * citySize;
                
                const color = colors[Math.floor(Math.random() * colors.length)];
                const intensity = Math.random() * 0.5 + 0.5;
                const distance = Math.random() * 100 + 50;
                
                const light = new THREE.PointLight(color, intensity, distance);
                light.position.set(x, y, z);
                scene.add(light);
            }
            
            return { ambientLight, sunLight };
        }
        
        // Set up camera and controls
        function setupCamera() {
            camera.position.set(0, 100, 350);
            camera.lookAt(0, 0, 0);
            
            // Add camera animation
            const cameraAnimData = {
                angle: 0,
                radius: 350,
                height: 100,
                speed: 0.001
            };
            
            return cameraAnimData;
        }
        
        // Initialize sliders
        function setupControls() {
            const timeSlider = document.getElementById('timeSlider');
            const trafficSlider = document.getElementById('trafficSlider');
            const fogSlider = document.getElementById('fogSlider');
            const neonSlider = document.getElementById('neonSlider');
            const cameraHeightSlider = document.getElementById('cameraHeightSlider');
            
            const controlData = {
                time: parseFloat(timeSlider.value),
                traffic: parseFloat(trafficSlider.value),
                fog: parseFloat(fogSlider.value),
                neon: parseFloat(neonSlider.value),
                cameraHeight: parseFloat(cameraHeightSlider.value)
            };
            
            // Event listeners
            timeSlider.addEventListener('input', (e) => {
                controlData.time = parseFloat(e.target.value);
                updateTimeOfDay(controlData.time);
            });
            
            trafficSlider.addEventListener('input', (e) => {
                controlData.traffic = parseFloat(e.target.value);
                updateTraffic();
            });
            
            fogSlider.addEventListener('input', (e) => {
                controlData.fog = parseFloat(e.target.value);
                scene.fog.density = controlData.fog;
            });
            
            neonSlider.addEventListener('input', (e) => {
                controlData.neon = parseFloat(e.target.value);
                updateNeonIntensity();
            });
            
            cameraHeightSlider.addEventListener('input', (e) => {
                controlData.cameraHeight = parseFloat(e.target.value);
            });
            
            return controlData;
        }
        
        // Update scene based on time of day
        function updateTimeOfDay(time) {
            // Calculate sun position
            const angle = ((time - 6) / 24) * Math.PI * 2;
            const height = Math.sin(angle);
            const distance = 1000;
            
            sunLight.position.x = Math.cos(angle) * distance;
            sunLight.position.y = height * distance;
            sunLight.position.z = Math.sin(angle + Math.PI/2) * distance;
            
            // Update light intensity based on time
            const isDaytime = height > 0;
            const sunIntensity = isDaytime ? Math.max(0.1, height) : 0;
            
            sunLight.intensity = sunIntensity;
            ambientLight.intensity = isDaytime ? 0.2 + sunIntensity * 0.3 : 0.05;
            
            // Update sky color
            let skyColor;
            
            if (height > 0.6) { // Midday
                skyColor = new THREE.Color(0x87CEEB);
            } else if (height > 0.1) { // Morning/afternoon
                const t = (height - 0.1) / 0.5;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0xFFA07A), // Sunrise/sunset color
                    new THREE.Color(0x87CEEB), // Midday color
                    t
                );
            } else if (height > -0.1) { // Sunrise/sunset
                skyColor = new THREE.Color(0xFFA07A);
            } else { // Night
                skyColor = new THREE.Color(0x000022);
            }
            
            sky.material.color = skyColor;
            
            // Update stars visibility
            starMaterial.opacity = isDaytime ? 0 : Math.min(1, Math.abs(height) * 3);
            
            // Update neon intensity based on time of day
            const baseNeonIntensity = isDaytime ? 0.2 : 1;
            updateNeonIntensity(baseNeonIntensity);
        }
        
        // Update traffic
        function updateTraffic() {
            vehicles.visible = controlData.traffic > 0;
        }
        
        // Update neon intensity
        function updateNeonIntensity(baseIntensity = null) {
            const neonIntensity = (baseIntensity !== null ? baseIntensity : 1) * controlData.neon;
            
            neonElements.traverse((child) => {
                if (child.isMesh && child.material.emissive) {
                    child.material.emissiveIntensity = neonIntensity;
                }
            });
            
            // Update vehicle lights too
            vehicles.traverse((child) => {
                if (child.isMesh && child.material.emissive) {
                    child.material.emissiveIntensity = neonIntensity;
                }
            });
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Create the city
        const { ambientLight, sunLight } = setupLights();
        const cameraAnimData = setupCamera();
        const controlData = setupControls();
        createCity();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera position
            if (!isDragging) {
                cameraAnimData.angle += cameraAnimData.speed;
                camera.position.x = Math.cos(cameraAnimData.angle) * cameraAnimData.radius;
                camera.position.z = Math.sin(cameraAnimData.angle) * cameraAnimData.radius;
                camera.position.y = controlData.cameraHeight;
                camera.lookAt(0, 0, 0);
            }
            
            // Animate vehicles
            vehicles.children.forEach((vehicle) => {
                if (vehicle.userData.speed) {
                    // Ground vehicles
                    if (vehicle.position.y < 10) {
                        const speed = vehicle.userData.speed * controlData.traffic;
                        const direction = vehicle.userData.direction;
                        
                        if (vehicle.rotation.y === 0) {
                            vehicle.position.z += speed * direction;
                            
                            // Loop around if out of bounds
                            if (Math.abs(vehicle.position.z) > citySize/2) {
                                vehicle.position.z = -citySize/2 * direction;
                            }
                        } else {
                            vehicle.position.x += speed * direction;
                            
                            // Loop around if out of bounds
                            if (Math.abs(vehicle.position.x) > citySize/2) {
                                vehicle.position.x = -citySize/2 * direction;
                            }
                        }
                    } 
                    // Flying vehicles
                    else {
                        const speed = vehicle.userData.speed * controlData.traffic;
                        const wobbleAmount = vehicle.userData.wobble;
                        const wobbleSpeed = vehicle.userData.wobbleSpeed;
                        
                        // Move forward
                        vehicle.translateZ(-speed);
                        
                        // Add wobble
                        vehicle.position.y += Math.sin(Date.now() * wobbleSpeed) * wobbleAmount;
                        
                        // Loop around if out of bounds
                        if (Math.abs(vehicle.position.x) > citySize/2 || 
                            Math.abs(vehicle.position.z) > citySize/2) {
                            vehicle.position.set(
                                (Math.random() - 0.5) * citySize,
                                Math.random() * 200 + 50,
                                (Math.random() - 0.5) * citySize
                            );
                            
                            vehicle.rotation.y = Math.random() * Math.PI * 2;
                        }
                    }
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Camera control
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                if (e.buttons === 1) { // Left mouse button
                    // Orbit camera
                    cameraAnimData.angle -= deltaMove.x * 0.01;
                    
                    camera.position.x = Math.cos(cameraAnimData.angle) * cameraAnimData.radius;
                    camera.position.z = Math.sin(cameraAnimData.angle) * cameraAnimData.radius;
                    camera.lookAt(0, 0, 0);
                }
                
                previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            }
        });
        
        // Mouse wheel to zoom
        document.addEventListener('wheel', (e) => {
            const zoomSensitivity = 30;
            cameraAnimData.radius += e.deltaY / zoomSensitivity;
            
            // Clamp to reasonable values
            cameraAnimData.radius = Math.max(50, Math.min(cameraAnimData.radius, 1000));
            
            camera.position.x = Math.cos(cameraAnimData.angle) * cameraAnimData.radius;
            camera.position.z = Math.sin(cameraAnimData.angle) * cameraAnimData.radius;
        });
        
        // Start animation
        updateTimeOfDay(controlData.time);
        animate();
    </script>
</body>
</html>
